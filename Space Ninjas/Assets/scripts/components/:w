
using UnityEngine;
using UnityEngine.UI;
using System.Collections;

// Not physics-based.
public class SmoothChaser : MonoBehaviour {

    public Transform target;

    private Vector3 smoothVel;
    public float pullAccel = 5f;
    public float normalSpeed = 10f;
    public float tangentSpeed = 10f;

    void Start() {
    }

    void Update() {
        // damp the speed towards the target
        Vector3 normal = (transform.position - target.position).normalized;
        Vector3 tangent = normal.Rotated(90f);

        // apply force towards the center (thus -1)
        normalSpeed += pullAccel * Time.deltaTime;
        normalSpeed = Mathf.Max(0f, normalSpeed);

        // recompose velocity and apply
        Vector3 velocity = normal*normalSpeed + tangent*tangentSpeed;
        transform.Translate(velocity * Time.deltaTime);
    }

    /* not entirely happy with how this looks

    public float initSpeed = 10f;
    public float smoothAccel = 0.2f;
    public float accel = 1f;

    private Vector3 velocity;
    private float angleSmoothVel = 0f;
    private float smoothTime = 1f;
    private float speed = 0f;

    void Start() {
        // start by going away from the target
        velocity = (target.position - transform.position).normalized * initSpeed * -1;
        speed = initSpeed;
    }

    void Update() {
        speed += accel * Time.deltaTime;

        smoothTime -= Mathf.Max(0f, smoothAccel * Time.deltaTime);
        Vector3 toTarget = (target.position - transform.position).normalized;
        float currAngle = Vector3.Angle(toTarget, velocity);
        float newAngle = Mathf.SmoothDampAngle(currAngle, 0f, ref angleSmoothVel, smoothTime);
        float deltaAngle = Mathf.DeltaAngle(currAngle, newAngle);
        Vector3 perp = Vector3.Cross(toTarget, velocity.normalized);
        if( Mathf.Abs(perp.z) < 1e-4 ) {
            // near opposite directions - have to just choose one
            perp = new Vector3(0f, 0f, Random.value < 0.5f ? -1f : 1f);
        }
        Quaternion rot = Quaternion.AngleAxis(deltaAngle, perp);
        Vector3 newDir = rot * velocity.normalized;
        velocity = newDir * speed;

        transform.Translate(velocity * Time.deltaTime);
    }
    */
}
